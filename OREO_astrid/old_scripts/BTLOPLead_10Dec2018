import os
import subprocess
import time

# Default OREO Values
oreo={}
oreo['OnOffDuration']=120
oreo['OnOffDelRA']=1.0
oreo['OnOffDelDec']=0.0
oreo['pulsarDuration']=120
oreo['obsDuration']=120
oreo['setTimeLimit']=4.*oreo['obsDuration']/3600.
oreo['maxMoveTime']=1e10
oreo['numBreakSources']=1000
oreo['solarAvoid']=10
oreo['lunarAvoid']=2
oreo['primaryAvoidFWHM']=5
oreo['tsysTolerance'] = 15
oreo['tsysNSamps'] = 4
oreo['tsysLogFile'] = "../logfile.txt"

#----------------------
# Fill in Oreo dictionary from what cleo returns
def parseCLEO2OREO( arr ):
    global oreo
    aa=arr.split()
    for j in range(0,len(aa),2):
        oreo[aa[j]]=aa[j+1]

#----------------------
# Fill in dictionary for secondary sources from what cleo returns
def parseSecondaries( arr ):
    global secondarySrcs
    aa=arr.split()
    for j in range(0,len(aa),4):
        secondarySrcs["srcName"+str(j/4)]=aa[j]
        secondarySrcs["srcRA"+str(j/4)]=aa[j+2]
        secondarySrcs["srcDec"+str(j/4)]=aa[j+3]

#----------------------
# Since primary and secondary catalogs are huge, cannot use them directly
# Instead, do everything a catlog would do: create a location object and modify 
# the M&C's source name
def obsSource( name, ra, dec, duration ):

    print "Observing ", name, ra, dec, " for ", duration, " seconds"
    SetValues('ScanCoordinator', {'source': name})
    Track(Location("J2000", ra, dec), None, duration)

#----------------------
# Wrapper for an AutoPeak(Focus) for a position near that of objName
def pntFoc( objName, doConfig ):

    global oreo

    Slew(objName)
    oreo['telPos'] = str(GetCurrentLocation("Encoder")).replace(" ","")

    if oreo['doFocus'] == "T":
        print "AutoPeakFocus", objName
        AutoPeakFocus(location=objName,balance=False)
    else:
       print "AutoPeak", objName
       AutoPeak(location=objName,balance=False)

    if oreo['online']:
        print "Updating Tsys logfile"
        p = subprocess.Popen(["logTsysPointing.tclsh", str(oreo)],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        (rslts, errP) = p.communicate()
        if errP != "":
            print errP
            Break(errP,600)

    if oreo['online'] and doConfig:
        print "Reconfiguring using:", oreo['configFile']
        Configure(oreo['configFile'],Balance=False)
        execfile(oreo['configFile'])

    Slew(objName)
     

#----------------------
# Hack as a way to determine if we're on or ofline
if GetLST() is None :
    print "You are working OFFLINE"
    oreo["online"]=False
else:
    print "Warning:  You are working ONLINE"
    oreo["online"]=True


# **** The home of the external routines needs to be esatblished
os.chdir( "/users/rmaddale/BTL/CurrentVersion")

#----------------------
# Ask the operator questions via a TCL dialog box
#
p = subprocess.Popen(["askQuestion.tclsh"],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
(rslts, errP) = p.communicate()
if errP != "":
    print "**** Error in determining receiver:", errP
    Break("**** Error in determining receiver")
else:
    parseCLEO2OREO(rslts)

    # Time for end of session
    stopTime = float(oreo['sessionDur'])*3600 + time.time()

    #-------------------------
    Catalog(oreo['pulsarCat'])
    Catalog(oreo['calibCat'])

    #--------------------------
    print "Configuring using:", oreo["configFile"]
    if oreo['online']:
        execfile(oreo['configFile'])

    #--------------------------
    # Find name of calibrator with the minimum move time
    #
    if oreo['doCalib'] == "1":

        Balance()
        oreo['telPos'] = str(GetCurrentLocation("Encoder")).replace(" ","")

        p = subprocess.Popen(["whichSources.tclsh", "numSrcs 0", "catalog", oreo['calibCat'], str(oreo)],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        (calSrc, errP) = p.communicate()
        if errP != "":
            print errP
            Break(errP)

        print "Selected calibrator:", calSrc

        if oreo['doPnt'] == "1":
            pntFoc(calSrc, True)
            oreo['doPnt']="0"

        OnOff(calSrc,Offset('J2000', oreo['OnOffDelRA'], oreo['OnOffDelDec'], cosv=False), oreo['OnOffDuration'], '1')

    #--------------------------
    # Pulsar
    #
    if oreo['doPulsar'] == "1":

        oreo['telPos'] = str(GetCurrentLocation("Encoder")).replace(" ","")
        p = subprocess.Popen(["whichSources.tclsh", "numSrcs 0", "catalog", oreo['pulsarCat'], str(oreo)],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        (psrSrc, errP) = p.communicate()
        if errP != "":
            print errP
            Break(errP)

        print "Selected pulsar:", psrSrc

        if oreo['doPnt'] == "1":
            pntFoc(psrSrc, True)
            doPnt="0"
        
        Track(psrSrc,None,oreo['pulsarDuration'])

    # Primary and secondary sources
    #
    while time.time() < stopTime:

        # Find a primary source
        oreo['telPos'] = str(GetCurrentLocation("Encoder")).replace(" ","")
        p = subprocess.Popen(["whichSources.tclsh", "numSrcs 1", "catalog", oreo['primaryCat'], str(oreo)],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        (rslts, errP) = p.communicate()
        if errP != "":
            print errP
            Break(errP)

        (primeSrcName,mt,primeSrcRa,primeSrcDec)=rslts.split()

        print "Selected primary:", primeSrcName, primeSrcRa, primeSrcDec

        primeLoc=Location('J2000', primeSrcRa, primeSrcDec)
        Slew(primeLoc)

        # Do we still need to point?  Or, is anothe rone needed?
        oreo['telPos'] = str(GetCurrentLocation("Encoder")).replace(" ","")
        p = subprocess.Popen(["isPointingNeeded.tclsh",str(oreo)],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        (needToPoint, errP) = p.communicate()
        if errP != "":
            print errP
            Break(errP)

        if oreo['doPnt'] == "1" or needToPoint == "1":
            pntFoc(primeLoc, True)
            doPnt="0"

        # Find three secondary sources
        p = subprocess.Popen(["whichSources.tclsh", "numSrcs 3", "catalog", oreo['secondaryCat'], str(oreo)],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        (rslts, errP) = p.communicate()
        if errP != "":
            print errP
            Break(errP)

        secondarySrcs={}
        parseSecondaries(rslts)

        print "Selected secondaries"
        for j in range(0,3):
            print "     ", j, secondarySrcs["srcName"+str(j)], secondarySrcs["srcRA"+str(j)], secondarySrcs["srcDec"+str(j)]

        # OK... do the observing (finally)
        for j in range(0,3):
            obsSource(primeSrcName,                    primeSrcRa,                    primeSrcDec,              oreo['obsDuration'])
            obsSource(secondarySrcs["srcName"+str(j)], secondarySrcs["srcRA"+str(j)], secondarySrcs["srcDec"+str(j)], oreo['obsDuration'])

        if oreo['online']: 
            print "Updating catalogs"

            # primary source
            p = subprocess.Popen(["updateCatalog.tclsh", primeSrcName, oreo['primaryCat'], oreo['rcvr']],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
            (rslts, errP) = p.communicate()
            if errP != "":
                print errP
                Break(errP)

            # secondary sources
            for j in range(0,3):
                p = subprocess.Popen(["updateCatalog.tclsh", secondarySrcs["srcName"+str(j)], oreo['secondaryCat'], oreo['rcvr']],stdout=subprocess.PIPE,stderr=subprocess.PIPE)
                (rslts, errP) = p.communicate()
                if errP != "":
                    print errP
                    Break(errP)

        if not oreo['online']:
            # If we are not online, then exit the while loop
            stopTime = 0
